<h3>Painter Demo</h3>

<script type="text/babel">
  const cable = ActionCable.createConsumer()

  const useBbox = () => {
    const ref = React.useRef()
    const [bbox, setBbox] = React.useState({})

    const set = () => setBbox(ref && ref.current ? ref.current.getBoundingClientRect() : {})

    React.useEffect(() => {
      set()
      window.addEventListener('resize', set)
      return () => window.removeEventListener('resize', set)
    }, [])

    return [bbox, ref]
  }

  const synchronizer = new function() {
    const objects = []

    return {
      save: (type, cmds) => {
        objects << { type, cmds, version: 1 }
      },
    }
  }

  const drawTools = {
    pencil: new DrawToolPencil(),
  }

  function DrawToolPencil() {
    let currentPos, tid

    const drawCalls = []

    function draw(ctx, fromPos, toPos) {
      const diffX = toPos.x - fromPos.x
      const diffY = toPos.y - fromPos.y
      if (diffX === 0 && diffY === 0) return

      drawCalls.push([diffX, diffY])

      ctx.save()
      ctx.lineWidth = 3

      ctx.beginPath()
      ctx.lineCap = "round"
      ctx.moveTo(fromPos.x, fromPos.y)
      ctx.lineTo(toPos.x, toPos.y)

      ctx.stroke()
      ctx.closePath()
      ctx.restore()
    }

    function save() {
      synchronizer.save('pencil', drawCalls.splice(0, drawCalls.length))
    }

    return {
      onMouseDown: (ctx, cursorPos) => {
        currentPos = cursorPos
        drawCalls.push([cursorPos.x, cursorPos.y])
      },
      onMouseMove: (ctx, cursorPos) => {
        draw(ctx, currentPos, cursorPos)
        currentPos = cursorPos
      },
      onMouseUp: (_ctx, _cursorPos) => {
        clearTimeout(tid)
        tid = setTimeout(() => { save() }, 1000)
      },
    }
  }

  function Painter(props) {
    const [canvasBBox, canvasRef] = useBbox()
    const ctx = canvasRef.current?.getContext('2d')
    const drawToolRef = React.useRef(drawTools.pencil)
    const drawingToolRef = React.useRef(null)

    function calculatePos(e) {
      return { x: Math.round(e.clientX - canvasBBox.x), y: Math.round(e.clientY - canvasBBox.y) }
    }

    function onMouseDown(e) {
      if (drawingToolRef.current) return
      drawingToolRef.current = drawToolRef.current
      drawingToolRef.current.onMouseDown(ctx, calculatePos(e))
    }

    function onMouseMove(e) {
      if (drawingToolRef.current == null) return
      drawingToolRef.current.onMouseMove(ctx, calculatePos(e))
    }

    function onMouseUp(e) {
      if (drawingToolRef.current == null) return
      drawingToolRef.current.onMouseUp(ctx, calculatePos(e))
      drawingToolRef.current = null
    }

    return (
      <canvas
        width="640"
        height="480"
        style={ { border: '1px solid black' } }
        ref={canvasRef}
        onMouseDown={onMouseDown}
        onMouseMove={onMouseMove}
        onMouseUp={onMouseUp}
      />
    )
  }

  ReactDOM.render(
    <Painter />,
    document.getElementById('root'),
  )
</script>

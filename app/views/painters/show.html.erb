<h3>Painter Demo</h3>

<script type="text/babel">
  const cable = ActionCable.createConsumer()

  const useRefState = (initialValue) => {
    const [state, setState] = React.useState(initialValue)
    const stateRef = React.useRef(state)
    return [
      stateRef,
      (state) => {
        stateRef.current = state
        setState(state)
      }
    ]
  }

  const useBbox = () => {
    const ref = React.useRef()
    const [bbox, setBbox] = React.useState({})

    const set = () => setBbox(ref && ref.current ? ref.current.getBoundingClientRect() : {})

    React.useEffect(() => {
      set()
      window.addEventListener('resize', set)
      return () => window.removeEventListener('resize', set)
    }, [])

    return [bbox, ref]
  }

  class SketchExample extends React.Component {
    constructor(props) {
      super(props)
      this.state = {
        displayColorPicker: false,
        color: props.color,
      }
    }

    handleClick = () => {
      this.setState({ displayColorPicker: !this.state.displayColorPicker })
    }

    handleClose = () => {
      this.setState({ displayColorPicker: false })
    }

    handleChange = (color) => {
      this.setState({ color: color.hex })
      if (this.props.onChange) this.props.onChange(color)
    }

    render() {
      const styles = {
        color: {
          width: '36px',
          height: '14px',
          borderRadius: '2px',
          backgroundColor: this.state.color,
        },
        swatch: {
          padding: '5px',
          backgroundColor: '#fff',
          borderRadius: '1px',
          boxShadow: '0 0 0 1px rgba(0,0,0,.1)',
          display: 'inline-block',
          cursor: 'pointer',
          verticalAlign: 'middle',
        },
        popover: {
          position: 'absolute',
          zIndex: '2',
        },
        cover: {
          position: 'fixed',
          top: '0px',
          right: '0px',
          bottom: '0px',
          left: '0px',
        },
      }

      return (
        <>
          <div style={styles.swatch} onClick={this.handleClick}>
            <div style={styles.color} />
          </div>
          {
            this.state.displayColorPicker ? (
              <div style={styles.popover}>
                <div style={ styles.cover } onClick={this.handleClose}/>
                <ReactColor.SketchPicker color={this.state.color} onChange={this.handleChange} />
              </div>
            ) : null
          }

        </>
      )
    }
  }

  const synchronizer = new function() {
    const objects = []

    function render(ctx) {
      objects.forEach(object => drawTools[object.kind].render(ctx, object))
    }

    function load(object) {
      objects.push(object)
    }

    function save(object) {
      objects.push(object)

      const params = { object }

      $.ajax({
        url: '/painters',
        type: 'PUT',
        headers: {
          "Content-Type": "application/json",
        },
        data: JSON.stringify(params),
        success: response => {
        },
      })
    }

    return { save, load, render }
  }

  const KIND_PENCIL = 'pencil'

  const drawTools = {
    [KIND_PENCIL]: new DrawToolPencil(),
  }

  function DrawToolPencil() {
    let currentPos, currentLineWidth, currentColor

    const cmds = []

    function serialize(selectedCmds) {
      return {
        kind: KIND_PENCIL,
        cmds: selectedCmds,
        width: currentLineWidth,
        color: currentColor,
        version: 1,
      }
    }

    function render(ctx, object) {
      const { cmds, width, color } = object
      if (cmds.length === 0) return

      let fromX = cmds[0][0]
      let fromY = cmds[0][1]

      ctx.save()
      ctx.lineWidth = width
      ctx.strokeStyle = color
      ctx.lineCap = 'round'

      ctx.beginPath()
      for(let i = 1; i < cmds.length; ++i) {
        let diffX = cmds[i][0]
        let diffY = cmds[i][1]
        let toX = fromX + diffX
        let toY = fromY + diffY
        ctx.moveTo(fromX, fromY)
        ctx.lineTo(toX, toY)

        fromX = toX
        fromY = toY
      }

      ctx.stroke()
      ctx.closePath()
      ctx.restore()
    }

    function save() {
      synchronizer.save(serialize(cmds.splice(0, cmds.length)))
    }

    return {
      render,
      onMouseDown: (ctx, cursorPos, lineWidth, color) => {
        currentPos = cursorPos
        currentLineWidth = lineWidth
        currentColor = color
        cmds.push([cursorPos.x, cursorPos.y])
      },
      onMouseMove: (ctx, cursorPos) => {
        const diffX = cursorPos.x - currentPos.x
        const diffY = cursorPos.y - currentPos.y
        if (diffX === 0 && diffY === 0) return

        cmds.push([diffX, diffY])
        render(ctx, serialize([[currentPos.x, currentPos.y], [diffX, diffY]]))
        currentPos = cursorPos
      },
      onMouseUp: (_ctx, _cursorPos) => {
        save()
      },
    }
  }

  function Painter(_props) {
    const [canvasBBox, canvasRef] = useBbox()
    const [lineWidthRef, setLineWidth] = useRefState(3)
    const [lineColorRef, setLineColor] = useRefState('black')
    const getCtx = () => canvasRef.current?.getContext('2d')
    const drawToolRef = React.useRef(drawTools[KIND_PENCIL])
    const drawingToolRef = React.useRef(null)

    React.useEffect(() => {
      const channel = cable.subscriptions.create('PainterChannel', {
        connected: () => console.log('connected'),
        disconnected: () => console.log('disconnected'),
        received: function(data){
          synchronizer.load(data.object)
          synchronizer.render(getCtx())
        }
      })

      return () => {
        channel.unsubscribe()
      }
    }, [])

    function calculatePos(e) {
      return { x: Math.round(e.clientX - canvasBBox.x), y: Math.round(e.clientY - canvasBBox.y) }
    }

    function onMouseDown(e) {
      if (drawingToolRef.current) return
      drawingToolRef.current = drawToolRef.current
      drawingToolRef.current.onMouseDown(getCtx(), calculatePos(e), lineWidthRef.current, lineColorRef.current)
    }

    function onMouseMove(e) {
      if (drawingToolRef.current == null) return
      drawingToolRef.current.onMouseMove(getCtx(), calculatePos(e))
    }

    function onMouseUp(e) {
      if (drawingToolRef.current == null) return
      drawingToolRef.current.onMouseUp(getCtx(), calculatePos(e))
      drawingToolRef.current = null
    }

    if (canvasRef.current) synchronizer.render(getCtx())

    return (
      <div>
        <div>
          <canvas
            width="640"
            height="480"
            style={ { border: '1px solid black' } }
            ref={canvasRef}
            onMouseDown={onMouseDown}
            onMouseMove={onMouseMove}
            onMouseUp={onMouseUp}
          />
        </div>
        <div>
          粗細：
          <input
            type="number"
            value={lineWidthRef.current}
            min="1"
            max="30"
            onChange={e => setLineWidth(e.target.value)}
          />
        </div>
        <div style={{ marginTop: 5 }}>
          顏色：
          <SketchExample
            color={lineColorRef.current}
            onChange={color => setLineColor(color.hex)}
          />
        </div>
      </div>
    )
  }

  <%= @objects.to_json.html_safe %>.forEach(synchronizer.load)

  ReactDOM.render(
    <Painter />,
    document.getElementById('root'),
  )
</script>

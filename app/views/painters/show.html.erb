<h3>Painter Demo</h3>

<script type="text/babel">
  const cable = ActionCable.createConsumer()

  const useBbox = () => {
    const ref = React.useRef()
    const [bbox, setBbox] = React.useState({})

    const set = () => setBbox(ref && ref.current ? ref.current.getBoundingClientRect() : {})

    React.useEffect(() => {
      set()
      window.addEventListener('resize', set)
      return () => window.removeEventListener('resize', set)
    }, [])

    return [bbox, ref]
  }

  const synchronizer = new function() {
    const objects = []

    function render(ctx) {
      objects.forEach(object => drawTools[object.kind].render(ctx, object.cmds))
    }

    function load(object) {
      objects.push(object)
    }

    function save(object) {
      objects.push(object)

      const params = { object }

      $.ajax({
        url: '/painters',
        type: 'PUT',
        headers: {
          "Content-Type": "application/json",
        },
        data: JSON.stringify(params),
        success: response => {
        },
      });
    }

    return { save, load, render }
  }

  const KIND_PENCIL = 'pencil'

  const drawTools = {
    [KIND_PENCIL]: new DrawToolPencil(),
  }

  function DrawToolPencil() {
    let currentPos

    const cmds = []

    function serializeAndReset() {
      return {
        kind: KIND_PENCIL,
        cmds: cmds.splice(0, cmds.length),
        width: 3,
        color: 'red',
        version: 1,
      }
    }

    function render(ctx, cmds) {
      if (cmds.length === 0) return

      let fromX = cmds[0][0]
      let fromY = cmds[0][1]

      ctx.save()
      ctx.lineWidth = 3
      ctx.strokeStyle = 'red'
      ctx.lineCap = 'round'

      ctx.beginPath()
      for(let i = 1; i < cmds.length; ++i) {
        let diffX = cmds[i][0]
        let diffY = cmds[i][1]
        let toX = fromX + diffX
        let toY = fromY + diffY
        ctx.moveTo(fromX, fromY)
        ctx.lineTo(toX, toY)

        fromX = toX
        fromY = toY
      }

      ctx.stroke()
      ctx.closePath()
      ctx.restore()
    }

    function save() {
      synchronizer.save(serializeAndReset())
    }

    return {
      render,
      onMouseDown: (ctx, cursorPos) => {
        currentPos = cursorPos
        cmds.push([cursorPos.x, cursorPos.y])
      },
      onMouseMove: (ctx, cursorPos) => {
        const diffX = cursorPos.x - currentPos.x
        const diffY = cursorPos.y - currentPos.y
        if (diffX === 0 && diffY === 0) return

        cmds.push([diffX, diffY])
        render(ctx, [[currentPos.x, currentPos.y], [diffX, diffY]])
        currentPos = cursorPos
      },
      onMouseUp: (_ctx, _cursorPos) => {
        save()
      },
    }
  }

  function Painter(_props) {
    const [canvasBBox, canvasRef] = useBbox()
    const getCtx = () => canvasRef.current?.getContext('2d')
    const drawToolRef = React.useRef(drawTools[KIND_PENCIL])
    const drawingToolRef = React.useRef(null)

    React.useEffect(() => {
      const channel = cable.subscriptions.create('PainterChannel', {
        connected: () => console.log('connected'),
        disconnected: () => console.log('disconnected'),
        received: function(data){
          synchronizer.load(data.object)
          synchronizer.render(getCtx())
        }
      });

      return () => {
        channel.unsubscribe()
      }
    }, [])

    function calculatePos(e) {
      return { x: Math.round(e.clientX - canvasBBox.x), y: Math.round(e.clientY - canvasBBox.y) }
    }

    function onMouseDown(e) {
      if (drawingToolRef.current) return
      drawingToolRef.current = drawToolRef.current
      drawingToolRef.current.onMouseDown(getCtx(), calculatePos(e))
    }

    function onMouseMove(e) {
      if (drawingToolRef.current == null) return
      drawingToolRef.current.onMouseMove(getCtx(), calculatePos(e))
    }

    function onMouseUp(e) {
      if (drawingToolRef.current == null) return
      drawingToolRef.current.onMouseUp(getCtx(), calculatePos(e))
      drawingToolRef.current = null
    }

    if (canvasRef.current) synchronizer.render(getCtx())

    return (
      <canvas
        width="640"
        height="480"
        style={ { border: '1px solid black' } }
        ref={canvasRef}
        onMouseDown={onMouseDown}
        onMouseMove={onMouseMove}
        onMouseUp={onMouseUp}
      />
    )
  }

  <%= @objects.to_json.html_safe %>.forEach(synchronizer.load)

  ReactDOM.render(
    <Painter />,
    document.getElementById('root'),
  )
</script>
